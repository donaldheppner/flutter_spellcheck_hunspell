// ignore_for_file: always_specify_types
// ignore_for_file: camel_case_types
// ignore_for_file: non_constant_identifier_names

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// (Actually manually generated because ffigen failed in env)

import 'dart:ffi' as ffi;

/// Bindings for `src/flutter_spellcheck_hunspell.h`.
class HunspellBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  HunspellBindings(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  HunspellBindings.fromLookup(ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName) lookup)
    : _lookup = lookup;

  ffi.Pointer<HunspellHandle> Hunspell_create(ffi.Pointer<ffi.Char> aff_path, ffi.Pointer<ffi.Char> dic_path) {
    return _Hunspell_create(aff_path, dic_path);
  }

  late final _Hunspell_createPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<HunspellHandle> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>(
        'Hunspell_create',
      );
  late final _Hunspell_create =
      _Hunspell_createPtr.asFunction<
        ffi.Pointer<HunspellHandle> Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)
      >();

  void Hunspell_destroy(ffi.Pointer<HunspellHandle> handle) {
    return _Hunspell_destroy(handle);
  }

  late final _Hunspell_destroyPtr = _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<HunspellHandle>)>>(
    'Hunspell_destroy',
  );
  late final _Hunspell_destroy = _Hunspell_destroyPtr.asFunction<void Function(ffi.Pointer<HunspellHandle>)>();

  int Hunspell_spell(ffi.Pointer<HunspellHandle> handle, ffi.Pointer<ffi.Char> word) {
    return _Hunspell_spell(handle, word);
  }

  late final _Hunspell_spellPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<HunspellHandle>, ffi.Pointer<ffi.Char>)>>(
        'Hunspell_spell',
      );
  late final _Hunspell_spell =
      _Hunspell_spellPtr.asFunction<int Function(ffi.Pointer<HunspellHandle>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Pointer<ffi.Char>> Hunspell_suggest(
    ffi.Pointer<HunspellHandle> handle,
    ffi.Pointer<ffi.Char> word,
    ffi.Pointer<ffi.Int> count,
  ) {
    return _Hunspell_suggest(handle, word, count);
  }

  late final _Hunspell_suggestPtr =
      _lookup<
        ffi.NativeFunction<
          ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
            ffi.Pointer<HunspellHandle>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Int>,
          )
        >
      >('Hunspell_suggest');
  late final _Hunspell_suggest =
      _Hunspell_suggestPtr.asFunction<
        ffi.Pointer<ffi.Pointer<ffi.Char>> Function(
          ffi.Pointer<HunspellHandle>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Int>,
        )
      >();

  void Hunspell_free_suggestions(ffi.Pointer<HunspellHandle> handle, ffi.Pointer<ffi.Pointer<ffi.Char>> slist, int n) {
    return _Hunspell_free_suggestions(handle, slist, n);
  }

  late final _Hunspell_free_suggestionsPtr =
      _lookup<
        ffi.NativeFunction<ffi.Void Function(ffi.Pointer<HunspellHandle>, ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>
      >('Hunspell_free_suggestions');
  late final _Hunspell_free_suggestions =
      _Hunspell_free_suggestionsPtr.asFunction<
        void Function(ffi.Pointer<HunspellHandle>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)
      >();
}

final class HunspellHandle extends ffi.Opaque {}
